//! AMX instruction set and execution

use crate::error::*;
use crate::types::*;

/// AMX instruction opcodes
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Opcode {
    // Load instructions
    LoadPri = 0x01,
    LoadAlt = 0x02,
    LoadSPri = 0x03,
    LoadSAlt = 0x04,
    LrefPri = 0x05,
    LrefAlt = 0x06,
    LrefSPri = 0x07,
    LrefSAlt = 0x08,
    LoadI = 0x09,
    LodbI = 0x0A,

    // Store instructions
    ConstPri = 0x0B,
    ConstAlt = 0x0C,
    AddrPri = 0x0D,
    AddrAlt = 0x0E,
    StorPri = 0x0F,
    StorAlt = 0x10,
    StorSPri = 0x11,
    StorSAlt = 0x12,
    SrefPri = 0x13,
    SrefAlt = 0x14,
    SrefSPri = 0x15,
    SrefSAlt = 0x16,
    StorI = 0x17,
    StrbI = 0x18,

    // Stack instructions
    Lidx = 0x19,
    Idxaddr = 0x1A,
    LoadB = 0x1B,
    LoadW = 0x1C,
    LoadS = 0x1D,
    StorB = 0x1E,
    StorW = 0x1F,
    StorS = 0x20,

    // Arithmetic instructions
    Add = 0x21,
    Sub = 0x22,
    Smul = 0x23,
    Sdiv = 0x24,
    Srem = 0x25,
    Umul = 0x26,
    Udiv = 0x27,
    Urem = 0x28,
    And = 0x29,
    Or = 0x2A,
    Xor = 0x2B,
    Shl = 0x2C,
    Shr = 0x2D,
    Sshr = 0x2E,
    Inc = 0x2F,
    Dec = 0x30,
    Neg = 0x31,
    Invert = 0x32,

    // Comparison instructions
    Eq = 0x33,
    Neq = 0x34,
    Less = 0x35,
    Leq = 0x36,
    Grtr = 0x37,
    Geq = 0x38,
    Sless = 0x39,
    Sleq = 0x3A,
    Sgrtr = 0x3B,
    Sgeq = 0x3C,

    // Jump instructions
    Jump = 0x3D,
    Jzer = 0x3E,
    Jnz = 0x3F,
    Jeq = 0x40,
    Jneq = 0x41,
    Jless = 0x42,
    Jleq = 0x43,
    Jgrtr = 0x44,
    Jgeq = 0x45,
    Jsless = 0x46,
    Jsleq = 0x47,
    Jsgrtr = 0x48,
    Jsgeq = 0x49,
    ShlC = 0x4A,
    ShrC = 0x4B,
    SshrC = 0x4C,

    // Call instructions
    Call = 0x4D,
    CallI = 0x4E,
    Ret = 0x4F,
    Retn = 0x50,

    // Stack manipulation
    PushPri = 0x51,
    PushAlt = 0x52,
    PushR = 0x53,
    PushC = 0x54,
    Push = 0x55,
    PushS = 0x56,
    PopPri = 0x57,
    PopAlt = 0x58,

    // Stack frame
    Stack = 0x59,
    Heap = 0x5A,
    Proc = 0x5B,
    CallP = 0x5F,
    CallPRI = 0x60,
    CallALT = 0x61,
    Frame = 0x62,

    // System instructions
    Sysreq = 0x63,
    SysreqD = 0x64,
    SysreqC = 0x65,
    SysreqI = 0x66,
    SysreqP = 0x67,
    SysreqS = 0x68,
    SysreqT = 0x69,
    SysreqU = 0x6A,
    SysreqV = 0x6B,
    SysreqW = 0x6C,
    SysreqX = 0x6D,
    SysreqY = 0x6E,
    SysreqZ = 0x6F,

    // Switch instructions
    Switch = 0x70,
    Casetbl = 0x71,
    SwapPri = 0x72,
    SwapAlt = 0x73,
    PushAddr = 0x74,
    Nop = 0x75,

    // Symbol table instructions
    SymTag = 0x76,
    SymTagI = 0x77,
    SymTagP = 0x78,
    SymTagS = 0x79,
    SymTagT = 0x7A,
    SymTagU = 0x7B,
    SymTagV = 0x7C,
    SymTagW = 0x7D,
    SymTagX = 0x7E,
    SymTagY = 0x7F,
    SymTagZ = 0x80,

    // Additional instructions
    Break = 0x81,
    Sleep = 0x82,
    Halt = 0x83,
    Bounds = 0x84,
    BoundsI = 0x85,
    BoundsP = 0x86,
    BoundsS = 0x87,
    BoundsT = 0x88,
    BoundsU = 0x89,
    BoundsV = 0x8A,
    BoundsW = 0x8B,
    BoundsX = 0x8C,
    BoundsY = 0x8D,
    BoundsZ = 0x8E,

    // Macro instructions
    Macro = 0x8F,
    MacroI = 0x90,
    MacroP = 0x91,
    MacroS = 0x92,
    MacroT = 0x93,
    MacroU = 0x94,
    MacroV = 0x95,
    MacroW = 0x96,
    MacroX = 0x97,
    MacroY = 0x98,
    MacroZ = 0x99,

    // Statement instructions
    Stmt = 0x9A,
    StmtI = 0x9B,
    StmtP = 0x9C,
    StmtS = 0x9D,
    StmtT = 0x9E,
    StmtU = 0x9F,
    StmtV = 0xA0,
    StmtW = 0xA1,
    StmtX = 0xA2,
    StmtY = 0xA3,
    StmtZ = 0xA4,
}

impl Opcode {
    /// Get opcode from byte value
    pub fn from_byte(byte: u8) -> Option<Self> {
        match byte {
            0x01 => Some(Opcode::LoadPri),
            0x02 => Some(Opcode::LoadAlt),
            0x03 => Some(Opcode::LoadSPri),
            0x04 => Some(Opcode::LoadSAlt),
            0x05 => Some(Opcode::LrefPri),
            0x06 => Some(Opcode::LrefAlt),
            0x07 => Some(Opcode::LrefSPri),
            0x08 => Some(Opcode::LrefSAlt),
            0x09 => Some(Opcode::LoadI),
            0x0A => Some(Opcode::LodbI),
            0x0B => Some(Opcode::ConstPri),
            0x0C => Some(Opcode::ConstAlt),
            0x0D => Some(Opcode::AddrPri),
            0x0E => Some(Opcode::AddrAlt),
            0x0F => Some(Opcode::StorPri),
            0x10 => Some(Opcode::StorAlt),
            0x11 => Some(Opcode::StorSPri),
            0x12 => Some(Opcode::StorSAlt),
            0x13 => Some(Opcode::SrefPri),
            0x14 => Some(Opcode::SrefAlt),
            0x15 => Some(Opcode::SrefSPri),
            0x16 => Some(Opcode::SrefSAlt),
            0x17 => Some(Opcode::StorI),
            0x18 => Some(Opcode::StrbI),
            0x19 => Some(Opcode::Lidx),
            0x1A => Some(Opcode::Idxaddr),
            0x1B => Some(Opcode::LoadB),
            0x1C => Some(Opcode::LoadW),
            0x1D => Some(Opcode::LoadS),
            0x1E => Some(Opcode::StorB),
            0x1F => Some(Opcode::StorW),
            0x20 => Some(Opcode::StorS),
            0x21 => Some(Opcode::Add),
            0x22 => Some(Opcode::Sub),
            0x23 => Some(Opcode::Smul),
            0x24 => Some(Opcode::Sdiv),
            0x25 => Some(Opcode::Srem),
            0x26 => Some(Opcode::Umul),
            0x27 => Some(Opcode::Udiv),
            0x28 => Some(Opcode::Urem),
            0x29 => Some(Opcode::And),
            0x2A => Some(Opcode::Or),
            0x2B => Some(Opcode::Xor),
            0x2C => Some(Opcode::Shl),
            0x2D => Some(Opcode::Shr),
            0x2E => Some(Opcode::Sshr),
            0x2F => Some(Opcode::Inc),
            0x30 => Some(Opcode::Dec),
            0x31 => Some(Opcode::Neg),
            0x32 => Some(Opcode::Invert),
            0x33 => Some(Opcode::Eq),
            0x34 => Some(Opcode::Neq),
            0x35 => Some(Opcode::Less),
            0x36 => Some(Opcode::Leq),
            0x37 => Some(Opcode::Grtr),
            0x38 => Some(Opcode::Geq),
            0x39 => Some(Opcode::Sless),
            0x3A => Some(Opcode::Sleq),
            0x3B => Some(Opcode::Sgrtr),
            0x3C => Some(Opcode::Sgeq),
            0x3D => Some(Opcode::Jump),
            0x3E => Some(Opcode::Jzer),
            0x3F => Some(Opcode::Jnz),
            0x40 => Some(Opcode::Jeq),
            0x41 => Some(Opcode::Jneq),
            0x42 => Some(Opcode::Jless),
            0x43 => Some(Opcode::Jleq),
            0x44 => Some(Opcode::Jgrtr),
            0x45 => Some(Opcode::Jgeq),
            0x46 => Some(Opcode::Jsless),
            0x47 => Some(Opcode::Jsleq),
            0x48 => Some(Opcode::Jsgrtr),
            0x49 => Some(Opcode::Jsgeq),
            0x4A => Some(Opcode::ShlC),
            0x4B => Some(Opcode::ShrC),
            0x4C => Some(Opcode::SshrC),
            0x4D => Some(Opcode::Call),
            0x4E => Some(Opcode::CallI),
            0x4F => Some(Opcode::Ret),
            0x50 => Some(Opcode::Retn),
            0x51 => Some(Opcode::PushPri),
            0x52 => Some(Opcode::PushAlt),
            0x53 => Some(Opcode::PushR),
            0x54 => Some(Opcode::PushC),
            0x55 => Some(Opcode::Push),
            0x56 => Some(Opcode::PushS),
            0x57 => Some(Opcode::PopPri),
            0x58 => Some(Opcode::PopAlt),
            0x59 => Some(Opcode::Stack),
            0x5A => Some(Opcode::Heap),
            0x5B => Some(Opcode::Proc),
            0x5C => Some(Opcode::Retn),
            0x5D => Some(Opcode::Call),
            0x5E => Some(Opcode::CallI),
            0x5F => Some(Opcode::CallP),
            0x60 => Some(Opcode::CallPRI),
            0x61 => Some(Opcode::CallALT),
            0x62 => Some(Opcode::Frame),
            0x63 => Some(Opcode::Sysreq),
            0x64 => Some(Opcode::SysreqD),
            0x65 => Some(Opcode::SysreqC),
            0x66 => Some(Opcode::SysreqI),
            0x67 => Some(Opcode::SysreqP),
            0x68 => Some(Opcode::SysreqS),
            0x69 => Some(Opcode::SysreqT),
            0x6A => Some(Opcode::SysreqU),
            0x6B => Some(Opcode::SysreqV),
            0x6C => Some(Opcode::SysreqW),
            0x6D => Some(Opcode::SysreqX),
            0x6E => Some(Opcode::SysreqY),
            0x6F => Some(Opcode::SysreqZ),
            0x70 => Some(Opcode::Switch),
            0x71 => Some(Opcode::Casetbl),
            0x72 => Some(Opcode::SwapPri),
            0x73 => Some(Opcode::SwapAlt),
            0x74 => Some(Opcode::PushAddr),
            0x75 => Some(Opcode::Nop),
            0x76 => Some(Opcode::SymTag),
            0x77 => Some(Opcode::SymTagI),
            0x78 => Some(Opcode::SymTagP),
            0x79 => Some(Opcode::SymTagS),
            0x7A => Some(Opcode::SymTagT),
            0x7B => Some(Opcode::SymTagU),
            0x7C => Some(Opcode::SymTagV),
            0x7D => Some(Opcode::SymTagW),
            0x7E => Some(Opcode::SymTagX),
            0x7F => Some(Opcode::SymTagY),
            0x80 => Some(Opcode::SymTagZ),
            0x81 => Some(Opcode::Break),
            0x82 => Some(Opcode::Sleep),
            0x83 => Some(Opcode::Halt),
            0x84 => Some(Opcode::Bounds),
            0x85 => Some(Opcode::BoundsI),
            0x86 => Some(Opcode::BoundsP),
            0x87 => Some(Opcode::BoundsS),
            0x88 => Some(Opcode::BoundsT),
            0x89 => Some(Opcode::BoundsU),
            0x8A => Some(Opcode::BoundsV),
            0x8B => Some(Opcode::BoundsW),
            0x8C => Some(Opcode::BoundsX),
            0x8D => Some(Opcode::BoundsY),
            0x8E => Some(Opcode::BoundsZ),
            0x8F => Some(Opcode::Macro),
            0x90 => Some(Opcode::MacroI),
            0x91 => Some(Opcode::MacroP),
            0x92 => Some(Opcode::MacroS),
            0x93 => Some(Opcode::MacroT),
            0x94 => Some(Opcode::MacroU),
            0x95 => Some(Opcode::MacroV),
            0x96 => Some(Opcode::MacroW),
            0x97 => Some(Opcode::MacroX),
            0x98 => Some(Opcode::MacroY),
            0x99 => Some(Opcode::MacroZ),
            0x9A => Some(Opcode::Stmt),
            0x9B => Some(Opcode::StmtI),
            0x9C => Some(Opcode::StmtP),
            0x9D => Some(Opcode::StmtS),
            0x9E => Some(Opcode::StmtT),
            0x9F => Some(Opcode::StmtU),
            0xA0 => Some(Opcode::StmtV),
            0xA1 => Some(Opcode::StmtW),
            0xA2 => Some(Opcode::StmtX),
            0xA3 => Some(Opcode::StmtY),
            0xA4 => Some(Opcode::StmtZ),
            _ => None,
        }
    }

    /// Get byte value of opcode
    pub fn to_byte(self) -> u8 {
        self as u8
    }

    /// Get human-readable name of opcode
    pub fn name(self) -> &'static str {
        match self {
            Opcode::LoadPri => "LOAD.pri",
            Opcode::LoadAlt => "LOAD.alt",
            Opcode::LoadSPri => "LOAD.S.pri",
            Opcode::LoadSAlt => "LOAD.S.alt",
            Opcode::LrefPri => "LREF.pri",
            Opcode::LrefAlt => "LREF.alt",
            Opcode::LrefSPri => "LREF.S.pri",
            Opcode::LrefSAlt => "LREF.S.alt",
            Opcode::LoadI => "LOAD.I",
            Opcode::LodbI => "LODB.I",
            Opcode::ConstPri => "CONST.pri",
            Opcode::ConstAlt => "CONST.alt",
            Opcode::AddrPri => "ADDR.pri",
            Opcode::AddrAlt => "ADDR.alt",
            Opcode::StorPri => "STOR.pri",
            Opcode::StorAlt => "STOR.alt",
            Opcode::StorSPri => "STOR.S.pri",
            Opcode::StorSAlt => "STOR.S.alt",
            Opcode::SrefPri => "SREF.pri",
            Opcode::SrefAlt => "SREF.alt",
            Opcode::SrefSPri => "SREF.S.pri",
            Opcode::SrefSAlt => "SREF.S.alt",
            Opcode::StorI => "STOR.I",
            Opcode::StrbI => "STRB.I",
            Opcode::Lidx => "LIDX",
            Opcode::Idxaddr => "IDXADDR",
            Opcode::LoadB => "LOAD.B",
            Opcode::LoadW => "LOAD.W",
            Opcode::LoadS => "LOAD.S",
            Opcode::StorB => "STOR.B",
            Opcode::StorW => "STOR.W",
            Opcode::StorS => "STOR.S",
            Opcode::Add => "ADD",
            Opcode::Sub => "SUB",
            Opcode::Smul => "SMUL",
            Opcode::Sdiv => "SDIV",
            Opcode::Srem => "SREM",
            Opcode::Umul => "UMUL",
            Opcode::Udiv => "UDIV",
            Opcode::Urem => "UREM",
            Opcode::And => "AND",
            Opcode::Or => "OR",
            Opcode::Xor => "XOR",
            Opcode::Shl => "SHL",
            Opcode::Shr => "SHR",
            Opcode::Sshr => "SSHR",
            Opcode::Inc => "INC",
            Opcode::Dec => "DEC",
            Opcode::Neg => "NEG",
            Opcode::Invert => "INVERT",
            Opcode::Eq => "EQ",
            Opcode::Neq => "NEQ",
            Opcode::Less => "LESS",
            Opcode::Leq => "LEQ",
            Opcode::Grtr => "GRTR",
            Opcode::Geq => "GEQ",
            Opcode::Sless => "SLESS",
            Opcode::Sleq => "SLEQ",
            Opcode::Sgrtr => "SGRTR",
            Opcode::Sgeq => "SGEQ",
            Opcode::Jump => "JUMP",
            Opcode::Jzer => "JZER",
            Opcode::Jnz => "JNZ",
            Opcode::Jeq => "JEQ",
            Opcode::Jneq => "JNEQ",
            Opcode::Jless => "JLESS",
            Opcode::Jleq => "JLEQ",
            Opcode::Jgrtr => "JGRTR",
            Opcode::Jgeq => "JGEQ",
            Opcode::Jsless => "JSLESS",
            Opcode::Jsleq => "JSLEQ",
            Opcode::Jsgrtr => "JSGRTR",
            Opcode::Jsgeq => "JSGEQ",
            Opcode::ShlC => "SHL.C",
            Opcode::ShrC => "SHR.C",
            Opcode::SshrC => "SSHR.C",
            Opcode::Call => "CALL",
            Opcode::CallI => "CALL.I",
            Opcode::Ret => "RET",
            Opcode::Retn => "RETN",
            Opcode::PushPri => "PUSH.pri",
            Opcode::PushAlt => "PUSH.alt",
            Opcode::PushR => "PUSH.R",
            Opcode::PushC => "PUSH.C",
            Opcode::Push => "PUSH",
            Opcode::PushS => "PUSH.S",
            Opcode::PopPri => "POP.pri",
            Opcode::PopAlt => "POP.alt",
            Opcode::Stack => "STACK",
            Opcode::Heap => "HEAP",
            Opcode::Proc => "PROC",
            Opcode::Frame => "FRAME",
            Opcode::CallP => "CALL.P",
            Opcode::CallPRI => "CALL.pri",
            Opcode::CallALT => "CALL.alt",
            Opcode::Sysreq => "SYSREQ",
            Opcode::SysreqD => "SYSREQ.D",
            Opcode::SysreqC => "SYSREQ.C",
            Opcode::SysreqI => "SYSREQ.I",
            Opcode::SysreqP => "SYSREQ.P",
            Opcode::SysreqS => "SYSREQ.S",
            Opcode::SysreqT => "SYSREQ.T",
            Opcode::SysreqU => "SYSREQ.U",
            Opcode::SysreqV => "SYSREQ.V",
            Opcode::SysreqW => "SYSREQ.W",
            Opcode::SysreqX => "SYSREQ.X",
            Opcode::SysreqY => "SYSREQ.Y",
            Opcode::SysreqZ => "SYSREQ.Z",
            Opcode::Switch => "SWITCH",
            Opcode::Casetbl => "CASETBL",
            Opcode::SwapPri => "SWAP.pri",
            Opcode::SwapAlt => "SWAP.alt",
            Opcode::PushAddr => "PUSH.ADDR",
            Opcode::Nop => "NOP",
            Opcode::SymTag => "SYMTAG",
            Opcode::SymTagI => "SYMTAG.I",
            Opcode::SymTagP => "SYMTAG.P",
            Opcode::SymTagS => "SYMTAG.S",
            Opcode::SymTagT => "SYMTAG.T",
            Opcode::SymTagU => "SYMTAG.U",
            Opcode::SymTagV => "SYMTAG.V",
            Opcode::SymTagW => "SYMTAG.W",
            Opcode::SymTagX => "SYMTAG.X",
            Opcode::SymTagY => "SYMTAG.Y",
            Opcode::SymTagZ => "SYMTAG.Z",
            Opcode::Break => "BREAK",
            Opcode::Sleep => "SLEEP",
            Opcode::Halt => "HALT",
            Opcode::Bounds => "BOUNDS",
            Opcode::BoundsI => "BOUNDS.I",
            Opcode::BoundsP => "BOUNDS.P",
            Opcode::BoundsS => "BOUNDS.S",
            Opcode::BoundsT => "BOUNDS.T",
            Opcode::BoundsU => "BOUNDS.U",
            Opcode::BoundsV => "BOUNDS.V",
            Opcode::BoundsW => "BOUNDS.W",
            Opcode::BoundsX => "BOUNDS.X",
            Opcode::BoundsY => "BOUNDS.Y",
            Opcode::BoundsZ => "BOUNDS.Z",
            Opcode::Macro => "MACRO",
            Opcode::MacroI => "MACRO.I",
            Opcode::MacroP => "MACRO.P",
            Opcode::MacroS => "MACRO.S",
            Opcode::MacroT => "MACRO.T",
            Opcode::MacroU => "MACRO.U",
            Opcode::MacroV => "MACRO.V",
            Opcode::MacroW => "MACRO.W",
            Opcode::MacroX => "MACRO.X",
            Opcode::MacroY => "MACRO.Y",
            Opcode::MacroZ => "MACRO.Z",
            Opcode::Stmt => "STMT",
            Opcode::StmtI => "STMT.I",
            Opcode::StmtP => "STMT.P",
            Opcode::StmtS => "STMT.S",
            Opcode::StmtT => "STMT.T",
            Opcode::StmtU => "STMT.U",
            Opcode::StmtV => "STMT.V",
            Opcode::StmtW => "STMT.W",
            Opcode::StmtX => "STMT.X",
            Opcode::StmtY => "STMT.Y",
            Opcode::StmtZ => "STMT.Z",
        }
    }
}

/// Instruction with operand
#[derive(Debug, Clone)]
pub struct Instruction {
    pub opcode: Opcode,
    pub operand: Cell,
}

impl Instruction {
    pub fn new(opcode: Opcode, operand: Cell) -> Self {
        Self { opcode, operand }
    }

    /// Read instruction from byte array
    pub fn from_bytes(data: &[u8], offset: usize) -> AmxResult<Self> {
        if offset + 5 > data.len() {
            return Err(AmxRuntimeError::InvalidInstruction(offset));
        }

        let opcode_byte = data[offset];
        let opcode = Opcode::from_byte(opcode_byte)
            .ok_or_else(|| AmxRuntimeError::InvalidInstruction(offset))?;

        let operand = Cell::from_le_bytes([
            data[offset + 1],
            data[offset + 2],
            data[offset + 3],
            data[offset + 4],
        ]);

        Ok(Self { opcode, operand })
    }

    /// Write instruction to byte array
    pub fn to_bytes(&self) -> [u8; 5] {
        let mut bytes = [0u8; 5];
        bytes[0] = self.opcode.to_byte();
        bytes[1..5].copy_from_slice(&self.operand.to_le_bytes());
        bytes
    }
}
